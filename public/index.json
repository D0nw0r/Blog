[{"categories":null,"content":"\rThe plotAs a developer, I am acustomed to having libraries that facilitate certain code actions such as math, randomness, http requests, etc. When it comes to C++, the standard library contains a whole arsenal of useful tools one can use to use the language to its full potential. An easy example are strings. Something we may take for granted by using std::string, but without the \u003cstring\u003e import, we would have to implement them in the traditional C style. (I know, it‚Äôs not that bad, just giving an example). In malware development, it‚Äôs a fairly common pratice to use reflective DLLs as an implant or loader. While newer stuff like PIC is available, the truth is that Reflective DLLs are still being used as the ‚Äògoto‚Äô format of malware commonly used. The concept is simple to understand, it is a DLL that is capable of loading itself in memory. Now, there are multiple ways of doing this as the techniques evolved over the years, we‚Äôre going to explore some to understand the problem I tried to fix. So what is the problem exactly? Well, like I mentioned before, I like using the C++ standard library and on Windows this is achieved by having a dependency called the CRT. The CRT is the C runtime, that contains all the necessary C and C++ functionality like strings, vectors, functions like memcpy, strlen, memset, etc. But when making reflective DLL, our code is supposed to be position independent (during the reflective loading, anyway), meaning it cannot have any dependencies. There are countless examples of Reflective DLLs online, but somehow I couldn‚Äôt find one that included the CRT. Or I should say, that explained why and how could we include the CRT. ","date":"2025-11-02","objectID":"http://localhost:1313/first_post/:1:0","series":null,"tags":null,"title":"A slightly different Reflective DLL","uri":"http://localhost:1313/first_post/#the-plot"},{"categories":null,"content":"\rLearning from failureThe typical Reflective DLL exports a function (usually called Reflective Function) that needs to be called so that the DLL can load itself into memory. This call is usually done by a specialized loader, increasing the overhead and complexity of the whole process. The flow is illustrated below: Loader reads ReflectiveDLL into memory Does some parsing until it finds the Exported function offset(Reflective Function) Inject the DLL on a process and create a thread starting at the Reflective Function From here the RDLL will load and execute itself. Once more, this is not ideal as it requires both a specialized loader and a DLL that exports a specific function, both are more likely to get flagged as mallicious behavior by security solutions. And using common examples of RDLL templates (I will be using the MaldevAcademy one, awesome content btw, highly recommend it to anyone), once we try to use some C/C++ functionality like printf, we are likely to see errors such as these: This error shows precisely that the linker is configured to not include the CRT, hence the unresolved dependencies of printf (which comes from stdio.h) ","date":"2025-11-02","objectID":"http://localhost:1313/first_post/:2:0","series":null,"tags":null,"title":"A slightly different Reflective DLL","uri":"http://localhost:1313/first_post/#learning-from-failure"},{"categories":null,"content":"\rA way forwardThe errors are relatively easy to fix, on this particular configuration the culprit was the Entry Point and the /NODEFAULTLIB, both under the Linker configurations on Visual Studio. Change the first to empty (It was DllMain) and the second to also empty (was Yes), and magicly you can include all the standard library magic within the Reflective DLL! But I was not satisfied enough with this approach. So I decided to do some more tweaks to the original code, which lead me down a rabbit hole of debugging, and that‚Äôs where I learned the most actually. This blogpost is meant to illustrate only that there are several ways of achieving the same outcome and that the end goal matters less than the journey sometimes. ","date":"2025-11-02","objectID":"http://localhost:1313/first_post/:3:0","series":null,"tags":null,"title":"A slightly different Reflective DLL","uri":"http://localhost:1313/first_post/#a-way-forward"},{"categories":null,"content":"\rWhy tho?Removing the CRT from malware has always divided me. I understand the reasons behind the practice originally, where reducing the size of the binary, removing unnecessary compiler optimizations helped get less detections. However, in the modern landscape I no longer believe this to be the case. A practice I follow and has yield good results, is that malware should try to mimick as much as possible ‚Äúreal‚Äù software to blend in. EDR evasion is not about zero alerts, it is about blending with the normal noise. Having said this, the majority of programs I have analyzed, do not strip the CRT from their binaries, and when it comes to size, modern binaries have sizes upwards of 20-100mb. So when trying to blend in, why should we remove a component that is used by legitimate software AND aids us on the development process? With this conclusion, I have explained my design choices for not only including the CRT on my RDLL, but removing compiler intrinsic versions of the legitimate functions like memcpy, memset, etc. ","date":"2025-11-02","objectID":"http://localhost:1313/first_post/:4:0","series":null,"tags":null,"title":"A slightly different Reflective DLL","uri":"http://localhost:1313/first_post/#why-tho"},{"categories":null,"content":"\rThe journeyThe first challenge I faced, was during the ReflectiveFunction‚Äôs execution, a step requires mapping the PE sections in memory. This was done by using a memcpy but not an ‚Äúoriginal‚Äù one, the version used was from a compiler intrinsic version. The problem here is that, even though on other parts of the code I will freely use the ‚Äúreal‚Äù memcpy function that lives in the CRT, for this specific operation during the ReflectiveFunction‚Äôs execution, since the DLL is loading itself in memory, there cannot be any dependencies, hence the original choice of using the intrinsic function replacement. What I did was replace this with a version of my own, that mimicks the behavior of the goal here, map the PE sections correctly: There was another instance of memcpy on the original code, that I also replaced with a simple for loop. c++ //memcpy(cForwarderName, pFunctionAddress, StringLengthA((PCHAR)pFunctionAddress)); for (int i = 0; i \u003c StringLengthA((PCHAR)pFunctionAddress); i++) { ((PUCHAR)cForwarderName)[i] = ((PUCHAR)pFunctionAddress)[i]; }\r","date":"2025-11-02","objectID":"http://localhost:1313/first_post/:5:0","series":null,"tags":null,"title":"A slightly different Reflective DLL","uri":"http://localhost:1313/first_post/#the-journey"},{"categories":null,"content":"\rThat anoying minor detail‚Ä¶Getting rid of any references to memcpy was easy, but the code also had an instrinsic function for memset. I found it odd because there were not references to it anywhere. I decided to ignore it, obviously. And it slapped right back into my face. The ReflectiveFunction kept crashing, so with the amazing help of Nick (from the Offensive Windows Dev Discord), I was able to debug and see what was happening. The program kept crashing with an access violation: text 0:021\u003e g (d88.5bdc): Access violation - code c0000005 (first chance) First chance exceptions are reported before any exception handling. This exception may be expected and handled. 00000195`8a161c6c ff252e080000 jmp qword ptr [00000195`8a1624a0] ds:00000195`8a1624a0=7273722e00000098\rCall stack: text 0:021\u003e k # Child-SP RetAddr Call Site 00 00000058`7a2ffa68 00000195`8a1607a5 0x00000195`8a161c6c 01 00000058`7a2ffa70 00000195`8a1600f8 0x00000195`8a1607a5 02 00000058`7a2ffa78 00000195`8a1601e8 0x00000195`8a1600f8 03 00000058`7a2ffa80 00000195`8a93cfa0 0x00000195`8a1601e8 04 00000058`7a2ffa88 00007ffb`5b5cb0ee 0x00000195`8a93cfa0 05 00000058`7a2ffa90 00007ffb`5b5cb01d ntdll!RtlpHpFreeWithExceptionProtection+0x1e 06 00000058`7a2ffb00 00007ffb`5b59e937 ntdll!RtlFreeHeap+0x6d 07 00000058`7a2ffb40 00007ffb`58c87ad0 ntdll!RtlFreeUnicodeString+0x17 08 00000058`7a2ffb70 00007ffb`58ce239f KERNELBASE!LoadLibraryExA+0x40 09 00000058`7a2ffbb0 00000195`8a160ae4 KERNELBASE!LoadLibraryA+0x3f 0a 00000058`7a2ffbe0 00000195`8a173980 0x00000195`8a160ae4 0b 00000058`7a2ffbe8 00007ffb`5aa60000 0x00000195`8a173980 0c 00000058`7a2ffbf0 00000000`000009a8 KERNEL32!Module32NextW \u003cPERF\u003e (KERNEL32+0x0) 0d 00000058`7a2ffbf8 00000195`8a173058 0x9a8 0e 00000058`7a2ffc00 00000000`00000000 0x00000195`8a173058\rWe can take a look at the last function called: text 0:021\u003e ub 00000195`8a1607a5 00000195`8a160780 0f8208010000 jb 00000195`8a16088e 00000195`8a160786 4a8d0426 lea rax,[rsi+r12] 00000195`8a16078a 483bd8 cmp rbx,rax 00000195`8a16078d 0f83fb000000 jae 00000195`8a16088e 00000195`8a160793 33d2 xor edx,edx 00000195`8a160795 488d4c2420 lea rcx,[rsp+20h] 00000195`8a16079a 41b804010000 mov r8d,104h 00000195`8a1607a0 e8c7140000 call 00000195`8a161c6c\re8c7140000 Let‚Äôs take this and spin up IDA: There it is! The memset call! But this wasn‚Äôt in any part of the C source code, how can it be calling it? The disassembly clearly tells us, but decompiling makes it even more clear: Where in our source code do we define cForwarderName? The compiler places a memset call if we initialize the array with zeroes! So we can just define it as: cpp CHAR cForwarderName[MAX_PATH];\rThis fixes the issue, finally let‚Äôs create some CRT imports by for example, having the string import and print: cpp case DLL_PROCESS_ATTACH: { Payload(); std::string mystring = \"hello\"; printf(\"%s\", mystring); ExitProcess(1); break; }\rNow, to test the result, we just need to inject it into a process: And by looking at the DLL on PE-Bear, we can clearly see that the CRT is being imported successfully! ","date":"2025-11-02","objectID":"http://localhost:1313/first_post/:6:0","series":null,"tags":null,"title":"A slightly different Reflective DLL","uri":"http://localhost:1313/first_post/#that-anoying-minor-detail"},{"categories":null,"content":"\rThe last mile is the longestI almost stopped here, I achieved my goal of having a RDLL that loads the CRT. But I did not like the way that I had to do a specialized loader, I wanted to avoid the overhead of manually looking for the exported function and redirecting execution to it specifically. As many of you know, sRDI exists and it is a straight up fix to this issue: https://github.com/monoxgas/sRDI Basically, instead of making the RDLL export a specific function, sRDI works by prepending the DLL with a blob of position independent code that does the loading of the DLL. This makes sRDI usable with any DLL, and as far as my knowledge goes, it is the most flexible way of achieving also my end goal, since you can load any DLL, their imports do not matter at all, the loader blob will parse and import all the requirements. By accident, I also found a very good article from IBM X-Force about the Cobalt Strike UDRL: https://www.ibm.com/think/x-force/defining-cobalt-strike-reflective-loader Upon reading it, about halfway Bobby talks about the way that Cobalt Strike‚Äôs Beacon is turned into shellcode, and I realized this could be yet another alternative that I could use. ","date":"2025-11-02","objectID":"http://localhost:1313/first_post/:7:0","series":null,"tags":null,"title":"A slightly different Reflective DLL","uri":"http://localhost:1313/first_post/#the-last-mile-is-the-longest"},{"categories":null,"content":"\rA slightly different RDLLInstead of prepending a loader to the DLL and exporting it as shellcode, why don‚Äôt we just use the initial bytes from the DLL itself? The image above is from the article mentioned beforehand, and the idea is that by patching the DLL‚Äôs initial bytes with assembly instructions that find the ReflectiveLoader function address and execute it, we no longer need a blob that loads the DLL into memory, making this a sort of hybrid between classic RDLL and the sRDI version. One caveat though, is that in Beacon‚Äôs case, DLLMain is still called after the ReflectiveLoader function executes. In my case, this is not needed as the function itself will call DllMain. This is an example of what the shellcode could look like (I use NeoVim, btw). So now, after patching the DLL and saving it as a binary file, we can use any shellcode loader to load our payload. ","date":"2025-11-02","objectID":"http://localhost:1313/first_post/:8:0","series":null,"tags":null,"title":"A slightly different Reflective DLL","uri":"http://localhost:1313/first_post/#a-slightly-different-rdll"},{"categories":null,"content":"\rWas this all worth the trouble?I went out to solve a problem that didn‚Äôt really require a solution (sRDI already existed), but I ended up learning a lot from the journey itself. Trying things and understanding why they work, their design choices, troubleshooting them are skills that I have found valuable to have in this field. I will be posting the code soon to my Github page, or should I re-write everything in Rust?‚Ä¶ ","date":"2025-11-02","objectID":"http://localhost:1313/first_post/:9:0","series":null,"tags":null,"title":"A slightly different Reflective DLL","uri":"http://localhost:1313/first_post/#was-this-all-worth-the-trouble"},{"categories":null,"content":"\rHey, I‚Äôm Diogo\rBinary Sunset is meant to be a collection of researches/struggles/ideas that I found some value in sharing with the security community. In this field, I cannot count the number of times that a ‚Äúrandom‚Äù blog has saved me when facing an uknown problem. Hopefully someone else will find these posts helpful. ","date":"2025-10-23","objectID":"http://localhost:1313/about/:0:0","series":null,"tags":null,"title":"About","uri":"http://localhost:1313/about/#hey-im-diogo"},{"categories":null,"content":"\rA little bit about meLearning about stuff, hacking stuff and writing stuff that hacks stuff are just about my favorite things. With an original background in programming, I have a passion for anything low level code related. ","date":"2025-10-23","objectID":"http://localhost:1313/about/:1:0","series":null,"tags":null,"title":"About","uri":"http://localhost:1313/about/#a-little-bit-about-me"},{"categories":null,"content":"\rWhat you‚Äôll see herePosts related with vulnerability research, exploit development, malware development, or just things I may find worth sharing! And because half the value is in documenting the struggles, not just the victories, I am aiming to document the roller-coaster that is the process of finding and exploiting vulnerabilities. ","date":"2025-10-23","objectID":"http://localhost:1313/about/:2:0","series":null,"tags":null,"title":"About","uri":"http://localhost:1313/about/#what-youll-see-here"},{"categories":null,"content":"\rWhy ‚ÄúBinary Sunset‚Äù?A nod to one of the most iconic scenes in Star Wars, where Luke stares at twin suns on Tatooine. It represents looking at something familiar from a different perspective ‚Äì much like security work, where we examine systems through an adversarial lens. Plus, I‚Äôm a huge Star Wars nerd. Had to sneak that in somewhere. ","date":"2025-10-23","objectID":"http://localhost:1313/about/:3:0","series":null,"tags":null,"title":"About","uri":"http://localhost:1313/about/#why-binary-sunset"},{"categories":null,"content":"\rGet in TouchAlways happy to chat about security, exploitation techniques, or debate which Star Wars trilogy is actually the best. You can find me on Twitter, GitHub, or LinkedIn. May the Force be with you. üåÖ ","date":"2025-10-23","objectID":"http://localhost:1313/about/:4:0","series":null,"tags":null,"title":"About","uri":"http://localhost:1313/about/#get-in-touch"}]